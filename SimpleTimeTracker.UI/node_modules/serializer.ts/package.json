{
  "_args": [
    [
      {
        "raw": "serializer.ts",
        "scope": null,
        "escapedName": "serializer.ts",
        "name": "serializer.ts",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "E:\\Users\\Scott\\Documents\\source\\SimpleTimeTracker\\SimpleTimeTracker.UI"
    ]
  ],
  "_from": "serializer.ts@latest",
  "_id": "serializer.ts@0.0.12",
  "_inCache": true,
  "_location": "/serializer.ts",
  "_nodeVersion": "5.4.1",
  "_npmOperationalInternal": {
    "host": "packages-16-east.internal.npmjs.com",
    "tmp": "tmp/serializer.ts-0.0.12.tgz_1460817481866_0.08264698390848935"
  },
  "_npmUser": {
    "name": "pleerock",
    "email": "zarrhost@gmail.com"
  },
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "raw": "serializer.ts",
    "scope": null,
    "escapedName": "serializer.ts",
    "name": "serializer.ts",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/serializer.ts/-/serializer.ts-0.0.12.tgz",
  "_shasum": "c28b20cd1cc0a359e479083b89e5e6b98f03e4eb",
  "_shrinkwrap": null,
  "_spec": "serializer.ts",
  "_where": "E:\\Users\\Scott\\Documents\\source\\SimpleTimeTracker\\SimpleTimeTracker.UI",
  "author": {
    "name": "Umed Khudoiberdiev",
    "email": "pleerock.me@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/pleerock/serializer.ts/issues"
  },
  "dependencies": {
    "reflect-metadata": "^0.1.3"
  },
  "description": "Proper serialization and deserialization raw json objects to classes in Typescript",
  "devDependencies": {
    "chai": "^3.4.1",
    "del": "^2.2.0",
    "gulp": "^3.9.1",
    "gulp-mocha": "^2.2.0",
    "gulp-replace": "^0.5.4",
    "gulp-shell": "^0.5.1",
    "gulp-tslint": "^4.3.3",
    "gulpclass": "0.1.0",
    "mocha": "^2.3.2",
    "sinon": "^1.17.2",
    "sinon-chai": "^2.8.0",
    "tslint": "^3.3.0",
    "tslint-stylish": "^2.1.0-beta",
    "typescript": "^1.8.9",
    "typings": "^0.7.9"
  },
  "directories": {},
  "dist": {
    "shasum": "c28b20cd1cc0a359e479083b89e5e6b98f03e4eb",
    "tarball": "https://registry.npmjs.org/serializer.ts/-/serializer.ts-0.0.12.tgz"
  },
  "homepage": "https://github.com/pleerock/serializer.ts#readme",
  "license": "Apache-2.0",
  "maintainers": [
    {
      "name": "pleerock",
      "email": "zarrhost@gmail.com"
    }
  ],
  "name": "serializer.ts",
  "optionalDependencies": {},
  "private": false,
  "readme": "# Serializer.ts\r\n\r\nSometimes you want to map raw json objects to the ES6 **classes** you have. For example, if you are getting json object\r\nfrom your backend, some api or from files, and after you `JSON.parse` it you have a plain javascript object, not\r\ninstance of class you have created.\r\n\r\nFor example you have a list of users in your `users.json` you are trying to load:\r\n\r\n```json\r\n[{\r\n  \"id\": 1,\r\n  \"firstName\": \"Johny\",\r\n  \"lastName\": \"Cage\",\r\n  \"age\": 27\r\n},\r\n{\r\n  \"id\": 2,\r\n  \"firstName\": \"Ismoil\",\r\n  \"lastName\": \"Somoni\",\r\n  \"age\": 50\r\n},\r\n{\r\n  \"id\": 3,\r\n  \"firstName\": \"Luke\",\r\n  \"lastName\": \"Dacascos\",\r\n  \"age\": 12\r\n}]\r\n```\r\nAnd you have a `User` class:\r\n\r\n```javascript\r\nexport class User {\r\n    id: number;\r\n    firstName: string;\r\n    lastName: string;\r\n    age: number;\r\n\r\n    getName() {\r\n        return this.firstName + \" \" + this.lastName;\r\n    }\r\n\r\n    isKid() {\r\n        return this.age < 18;\r\n    }\r\n}\r\n```\r\n\r\nYou are assuming that you are downloading users of type `User` from `users.json` file and may want to write\r\nfollowing code:\r\n\r\n```javascript\r\nfetch(\"users.json\").then((users: User[]) => {\r\n    // here you can use users[0].id, you can also use users[0].firstName and users[0].lastName\r\n    // however you cannot user users[0].getName() or users[0].isKid() because users object is actually\r\n    // array of plain javascript objects, not instances of User object. You told compiler that `users: User[]`\r\n    // you actually lied to your compiler that you are getting instances of User object.\r\n});\r\n```\r\n\r\nSo what to do? How to have in `users` array of `User` objects instead of plain javascript objects? Solution is\r\nto create new instances of User object and manually copy all properties to new objects.\r\n\r\nAlternatives? Yes, you can use this library. Purpose of this library is to help you to map you plain javascript\r\nobjects to the instances of classes you have created.\r\n\r\n## Installation\r\n\r\n\r\n1. Install module:\r\n\r\n    `npm install serializer.ts --save`\r\n\r\n2. Use [typings](https://github.com/typings/typings) to install all required definition dependencies.\r\n\r\n    `typings install`\r\n\r\n3. ES6 features are used, so you may want to install [es6-shim](https://github.com/paulmillr/es6-shim) too:\r\n\r\n    `npm install es6-shim --save`\r\n\r\n    if you are building nodejs app, you may want to `require(\"es6-shim\");` in your app.\r\n    or if you are building web app, you man want to add `<script src=\"path-to-shim/es6-shim.js\">` on your page.\r\n\r\n## Basic usage\r\n\r\nThis library allows you to perform both serialization and deserialization of the objects:\r\n\r\n#### serialization\r\n\r\n```javascript\r\nimport {serialize} from \"serializer.ts/Serializer\";\r\n\r\nlet photo = serialize(photo);\r\n```\r\n\r\nWork of `serialize` method may look like `JSON.parse` method, but benefit of using this method is that you can skip\r\nsome properties during serialization. Skipping is covered in next section.\r\n\r\n#### deserialization\r\n\r\n```javascript\r\nimport {deserialize} from \"serializer.ts/Serializer\";\r\n\r\nlet users = deserialize<User[]>(User, usersJson);\r\n```\r\n\r\nThis allows to map plain javascript array `usersJson` to array of `User` objects.\r\nNow you can use `users[0].getName()` and `users[0].isKid()` methods.\r\n\r\n## Nested objects\r\n\r\nWhen you deserialize objects that have nested objects, its required for this component to known what type of object\r\nyou are trying to deserialize. Since Typescript does not have good reflection abilities yet we must implicitly\r\nspecify what type of object each property contain. This is done using `@Type` decorator.\r\n\r\nLets say we have an album with photos. And we are trying to deserialize album object:\r\n\r\n```javascript\r\nimport {Type} from \"serializer.ts/Decorators\";\r\n\r\nexport class Album {\r\n\r\n    id: number;\r\n\r\n    name: string;\r\n\r\n    @Type(() => Photo)\r\n    photos: Photo[];\r\n}\r\n\r\nexport class Photo {\r\n    id: number;\r\n    filename: string;\r\n}\r\n\r\nlet album = deserialize<Album>(Album, albumJson);\r\n// now album is Album object with Photo objects inside\r\n```\r\n\r\n## Skipping specific properties\r\n\r\nSometimes you want to skip some properties during serialization/deserialization. This can be done using `@Skip`\r\ndecorator:\r\n\r\n```javascript\r\nimport {Skip} from \"serializer.ts/Decorators\";\r\n\r\nexport class User {\r\n\r\n    id: number;\r\n\r\n    email: string;\r\n\r\n    @Skip()\r\n    password: string;\r\n}\r\n```\r\n\r\nNow when you'll try to serialize or deserialize object `password` property will be skipped and will not be included\r\nin the serialized/deserialized object.\r\n\r\n## Converting date strings into Date objects\r\n\r\nSometimes you have dates in your plain old javascript objects received in a string format. And you want to create a\r\nreal javascript Date objects from them. To make deserializer to automatically make your date strings a Date objects\r\nsimply pass Date object to the `@Type` decorator:\r\n\r\n```javascript\r\nimport {Skip, Type} from \"serializer.ts/Decorators\";\r\n\r\nexport class User {\r\n\r\n    id: number;\r\n\r\n    email: string;\r\n\r\n    @Skip()\r\n    password: string;\r\n\r\n    @Type(() => Date)\r\n    registrationDate: Date;\r\n}\r\n```\r\n\r\nSame technique can be used with `Number`, `String`, `Boolean` primitive types when you want to convert your values\r\ninto these types.\r\n\r\n## Example with Angular2\r\n\r\nLets say you want to download users and want them automatically to be mapped to the instances of `User` class.\r\n\r\n```javascript\r\nimport {deserialize} from \"serializer.ts/Serializer\";\r\n\r\nthis.http\r\n    .get(\"users.json\")\r\n    .map(res => res.json())\r\n    .map(res => deserialize<User[]>(User, res))\r\n    .subscribe(users => {\r\n        // now \"users\" is type of User[] and each user have getName() and isKid() methods available\r\n        console.log(users);\r\n    });\r\n```\r\n\r\nYou can also inject a class `Serializer` as a service, and use its methods.\r\n\r\n## Samples\r\n\r\nTake a look on samples in [./sample](https://github.com/pleerock/serializer.ts/tree/master/sample) for more examples of\r\nusages.\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/pleerock/serializer.ts.git"
  },
  "scripts": {},
  "tags": [
    "serialization",
    "deserialization",
    "serializer",
    "typescript",
    "typescript-serializer"
  ],
  "version": "0.0.12"
}
